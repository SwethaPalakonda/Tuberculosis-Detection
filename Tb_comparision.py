# -*- coding: utf-8 -*-
"""tb_comparision.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UIvgdgMe8aTTAj6Ji8T9XsmgFh_u30jT

<div style="color: black; font-family: 'Times New Roman', serif; text-transform: uppercase; font-weight: bold; font-size: 24px; word-spacing: 10px;">
Mycobacterium Tuberculosis Detection Using CNN
</div>
"""

from google.colab import drive
drive.mount('/content/drive')

import cv2 as cv
import numpy as np
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split
import os

normaldir = '/content/drive/MyDrive/Myco/Normal'
tbdir = '/content/drive/MyDrive/Myco/Tuberculosis'
images = []
labels = []
imagesize = 256

for x in os.listdir(normaldir):
    imagedir = os.path.join(normaldir, x)
    image = cv.imread(imagedir, cv.IMREAD_GRAYSCALE)
    image = cv.resize(image, (imagesize, imagesize))
    images.append(image)
    labels.append(0)

for y in os.listdir(tbdir):
    imagedir = os.path.join(tbdir, y)
    image = cv.imread(imagedir, cv.IMREAD_GRAYSCALE)
    image = cv.resize(image, (imagesize, imagesize))
    images.append(image)
    labels.append(1)

images = np.array(images)
labels = np.array(labels)

#Splitting the images and labels into training and testing sets, then normalizing the values within them for computational efficiency (from 0-255 scale to 0-1 scale)
imagetrain, imagetest, labeltrain, labeltest = train_test_split(images, labels, test_size=0.3, random_state=42)
imagetrain = (imagetrain.astype('float32'))/255
imagetest = (imagetest.astype('float32'))/255

print(imagetrain.shape)  # This will give you the current shape

import numpy as np
from imblearn.over_sampling import SMOTE

# Example shape
imagetrain = np.random.rand(354, 256, 256)  # Replace with your actual data
labeltrain = np.random.randint(0, 2, 354)  # Example labels (binary)

# Flatten the images
imagetrain = imagetrain.reshape(354, 256 * 256)

# Apply SMOTE
smote = SMOTE(random_state=42)
imagetrain, labeltrain = smote.fit_resample(imagetrain, labeltrain)

# Reshape back to original image dimensions
imagetrain = imagetrain.reshape(-1, 256, 256, 1)

# Convert grayscale images to RGB for models
imagetrain = np.repeat(imagetrain, 3, axis=-1)

# Print the final shape
print(imagetrain.shape)  # Should reflect the new shape after processing

print(np.unique(labeltrain, return_counts=True))

"""## CNN"""

import numpy as np
from keras import layers, models
from keras.callbacks import ReduceLROnPlateau

# Assuming imagetrain and labeltrain are already defined

# Check shapes
print("Image shape:", imagetrain.shape)  # Expected: (378, 256, 256, 3)
print("Label shape:", labeltrain.shape)   # Expected: (378,)

# Define the CNN model for RGB images
cnn = models.Sequential([
    layers.Input(shape=(256, 256, 3)),  # Now accepting RGB input
    layers.Conv2D(16, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(32, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dropout(0.5),
    layers.Dense(1, activation='sigmoid')
])

# Compile the model
cnn.compile(
    loss='binary_crossentropy',
    optimizer=keras.optimizers.Adam(learning_rate=0.001),
    metrics=['accuracy']
)

# Set up the learning rate reduction callback
reduce_lr = ReduceLROnPlateau(monitor='accuracy', factor=0.1, patience=1, min_lr=0.00001, verbose=1)

# Fit the model
cnn.fit(imagetrain, labeltrain, batch_size=16, epochs=10, verbose=2, callbacks=[reduce_lr])

"""**InceptionV3**"""

from keras.applications import InceptionV3
from keras import layers, models

# Load the InceptionV3 model with pre-trained weights
base_model = InceptionV3(weights='imagenet', include_top=False, input_shape=(256, 256, 3))

# Freeze the base model
base_model.trainable = False

# Create the new model
inception_model = models.Sequential([
    base_model,
    layers.GlobalAveragePooling2D(),
    layers.Dense(64, activation='relu'),
    layers.Dropout(0.5),
    layers.Dense(1, activation='sigmoid')
])

# Compile the model
inception_model.compile(
    loss='binary_crossentropy',
    optimizer=keras.optimizers.Adam(learning_rate=0.001),
    metrics=['accuracy']
)

# Fit the model
inception_model.fit(imagetrain, labeltrain, batch_size=16, epochs=10, verbose=2, callbacks=[reduce_lr])

"""**ResNet50**"""

from keras.applications import ResNet50

# Load the ResNet50 model with pre-trained weights
base_model = ResNet50(weights='imagenet', include_top=False, input_shape=(256, 256, 3))

# Freeze the base model
base_model.trainable = False

# Create the new model
resnet_model = models.Sequential([
    base_model,
    layers.GlobalAveragePooling2D(),
    layers.Dense(64, activation='relu'),
    layers.Dropout(0.5),
    layers.Dense(1, activation='sigmoid')
])

# Compile the model
resnet_model.compile(
    loss='binary_crossentropy',
    optimizer=keras.optimizers.Adam(learning_rate=0.001),
    metrics=['accuracy']
)

# Fit the model
resnet_model.fit(imagetrain, labeltrain, batch_size=16, epochs=10, verbose=2, callbacks=[reduce_lr])

"""**Xception**"""

from keras.applications import Xception

# Load the Xception model with pre-trained weights
base_model = Xception(weights='imagenet', include_top=False, input_shape=(256, 256, 3))

# Freeze the base model
base_model.trainable = False

# Create the new model
xception_model = models.Sequential([
    base_model,
    layers.GlobalAveragePooling2D(),
    layers.Dense(64, activation='relu'),
    layers.Dropout(0.5),
    layers.Dense(1, activation='sigmoid')
])

# Compile the model
xception_model.compile(
    loss='binary_crossentropy',
    optimizer=keras.optimizers.Adam(learning_rate=0.001),
    metrics=['accuracy']
)

# Fit the model
xception_model.fit(imagetrain, labeltrain, batch_size=16, epochs=10, verbose=2, callbacks=[reduce_lr])

import cv2 as cv
import numpy as np
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split
import os
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, Dropout, Flatten
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import ReduceLROnPlateau
from tensorflow.keras.preprocessing.image import ImageDataGenerator

normaldir = '/content/drive/MyDrive/Myco/Normal'
tbdir = '/content/drive/MyDrive/Myco/Tuberculosis'
images = []
labels = []
imagesize = 224

for x in os.listdir(normaldir):
    imagedir = os.path.join(normaldir, x)
    image = cv.imread(imagedir, cv.IMREAD_GRAYSCALE)
    image = cv.resize(image, (imagesize, imagesize))
    image = np.expand_dims(image, axis=-1)
    images.append(image)
    labels.append(0)

for y in os.listdir(tbdir):
    imagedir = os.path.join(tbdir, y)
    image = cv.imread(imagedir, cv.IMREAD_GRAYSCALE)
    image = cv.resize(image, (imagesize, imagesize))
    image = np.expand_dims(image, axis=-1)
    images.append(image)
    labels.append(1)

images = np.array(images)
labels = np.array(labels)

imagetrain, imagetest, labeltrain, labeltest = train_test_split(images, labels, test_size=0.3, random_state=42)

imagetrain = (imagetrain.astype('float32')) / 255
imagetest = (imagetest.astype('float32')) / 255

imagetrain_rgb = np.repeat(imagetrain, 3, axis=-1)
imagetest_rgb = np.repeat(imagetest, 3, axis=-1)

base_model = MobileNetV2(weights='imagenet', include_top=False, input_shape=(imagesize, imagesize, 3))
base_model.trainable = False

x = base_model.output
x = Flatten()(x)
x = Dense(64, activation='relu')(x)
x = Dropout(0.5)(x)
predictions = Dense(1, activation='sigmoid')(x)

model = Model(inputs=base_model.input, outputs=predictions)

model.compile(
    loss='binary_crossentropy',
    optimizer=Adam(learning_rate=0.001),
    metrics=['accuracy']
)

reduce_lr = ReduceLROnPlateau(monitor='accuracy', factor=0.1, patience=1, min_lr=0.00001, verbose=1)

train_datagen = ImageDataGenerator(rescale=1./255)
test_datagen = ImageDataGenerator(rescale=1./255)

train_generator = train_datagen.flow(imagetrain_rgb, labeltrain, batch_size=16)
test_generator = test_datagen.flow(imagetest_rgb, labeltest, batch_size=16)

model.fit(train_generator, epochs=10, verbose=2, callbacks=[reduce_lr])

print('TESTING DATA:')
model.evaluate(test_generator, verbose=2)

print('ADVANCED TESTING METRICS:')
from sklearn.metrics import classification_report, confusion_matrix

predictions = model.predict(test_generator, batch_size=16)
predicted_labels = (predictions > 0.5).astype('int32')

print(classification_report(labeltest, predicted_labels))
print(confusion_matrix(labeltest, predicted_labels))
